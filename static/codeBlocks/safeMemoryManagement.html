<p>Follow this set of secure coding practices to prevent memory attacks.</p>
<h5>Use functions that limit the input size</h5>
<p> fgets(â€¦) allows limits the size of the input; <code>fgets(userPass, BUFF_SIZE, stdin)</code>. 
Other such functions are strncpy, snprintf and strncmp.
</p>
<h5>Check that the size of the input matches the size of the allocated memory.</h5>
<p>
Even with the use of a "safe function" buffer overflow can still occur if the size argument is larger than the size of the buffer. Avoid mistakes by using constants for memory allocation and controlling boundaries. 
Pay close attention to comparison operators.
</p>
<h5>Do not allow input as format string arguments.</h5>
<p>
If the user input is used in the format string portion of format string arguments this can lead to data leakage and even altering of memory integrity.
</p>
<h5>Safe releasing memory</h5>
<p>
    Memory issues don't only occur when allocating and constructing buffers. They also occur if memory is released unsafely.
    Use-after-free is another type of flaw where one portion of the code frees the memory and allocates it to a new variable
    however a different area of the code still uses that variable. This can lead to data leakage and crashes.
</p>
<h5>
    Safe compiler flags
</h5>
<p>Compiler flags enable operating system defences such as ASLR in Windows or PIE/SSP in Linux. 
    They tell the operating system to employ countermeasures such as randomizing memory, which is making it hard for attackers to insert arbitrary code.
</p>
<p>
        Even with compiler flags in place attackers can still crash the program so the main effect of compiler flags is reducing the impact of the attack. 
        The best defence is to prevent the flaws in the code, from the start, by employing the best practices discussed in this article.
</p>
